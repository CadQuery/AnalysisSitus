<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Analysis Situs: architecture overview</title>
  <link rel="shortcut icon" type="image/png" href="../imgs/favicon.png"/>
  <link rel="stylesheet" type="text/css" href="../css/situ-main-style.css">

  <!-- [begin] Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112292727-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-112292727-2');
  </script>
  <!-- [end] Google Analytics -->

 </head>
<body>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
  <td align="left" class="header">
    <span class="header-logo"><a href="../index.html" class="header-href">Analysis&nbsp;Situs</a></span>
    &nbsp;
    ./<a class="header-href" href="../features.html">features</a>/architecture overview
  </td>
</tr>
</table>
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
  <td class="header-menu"><a href='http://quaoar.su/blog/page/analysis-situs'>Download</a></td>
  <td class="header-menu"><a href="../features.html">Features</a></td>
  <td class="header-menu"><a href="https://gitlab.com/ssv/AnalysisSitus">Source code</a></td>
  <td class="header-menu"><a href="../terminology.html">Terminology</a></td>
  <td class="header-menu"><a href="../references.html">References</a></td>
</tr>
</table>

<h1>Architecture overview</h1>

<p>
All packages of Analysis Situs can be
divided logically to a <i>backend</i> and a <i>frontend</i> parts.
The contents of each part are schematically shown in the figure below.
</p>

<div align="center"><img src="../imgs/engineering_app_arch.png"/></div>

<p>
To represent Data Model, <a href="https://gitlab.com/ssv/active-data">Active Data</a>
framework is used. The Active Data framework is based on OCAF module of OpenCascade
kernel. The architecture of an OCAF-based application resembles a typical
architecture of an Enterprise application constructed on the top of a
database engine. In our case, we have OCAF (Active Data) serving as a hierarchical
no-sql in-memory database. At the layer above, all necessary
Data Access Objects (DAO) reside. These DAOs bring an object-oriented abstraction to the Data Model.
The Data Access Objects are also called Data Cursors (or Data Interfaces) as they
do not store any data in their member fields and only point to the corresponding
persistent entity (OCAF label) which can be used to read and write actual data.
Finally, at the top level of Data Model, we have Services which drive the business
logic of the application. It is the role of Service layer to update the contents of the
Data Model according to the user inputs.
</p>

<div align="center"><img src="../imgs/situ_arch_01.png"/></div>

<p>
Programmatically, the DAO layer of the architecture is realized
in <span class="code-inline">asiData</span> library. In this library, all
object interfaces are declared and implemented. For the Service layer, we
have a dedicated <span class="code-inline">asiEngine</span> library. In the
Service library, one can find classes like <span class="code-inline">asiEngine_Part</span>
or <span class="code-inline">asiEngine_IV</span> which contain the business logic
relevant to a specific object type (Part and Imperative Viewer for the mentioned
classes).
</p>

<p class="note">
For a Part object, a piece of business logic may assume recomputation of accelerating
structures or <a href="./features_aag.html">AAG</a> in case if the Part gets another B-Rep shape to store. In most cases,
it is a good idea to work with a Part (and other object types) via its Service API (i.e., <span class="code-inline">asiEngine_Part</span>)
instead of using the DAOs class (i.e., <span class="code-inline">asiData_Part</span>) directly. Calling API functions ensures that the
Data Model remains consistent.
</p>

<p>
An object in Analysis Situs software is called a Node following the convention
of the Active Data framework. A Node is defined with a list of its Parameters which
can be observed in the Parameter Editor panel of the desktop application. Additionally,
a Node may have different relations to other Nodes, including:
<ul>
  <li>Reference (with optional back-reference).</li>
  <li>Parent-child relation.</li>
  <li>Functional dependency (for parametric models).</li>
</ul>
</p>

<h1>Visualization</h1>

<p>
The visualization module (implemented in <span class="code-inline">asiVisu</span>
library) is tightly bounded to the Data Model backbone. For a Node to be represented in a
3D scene, the corresponding Presentation class is created. There is a one-to-one correspondence
between the Node types and the Presentation types. Practically, it means that whenever a new Node
type is introduced, the dual Presentation class should be created. A Presentation is essentially a
collection of Pipelines, where a Pipeline is an abstraction to represent the similar notion of
VTK visualization.
</p>

<div align="center"><img src="../imgs/situ_arch_02.png"/></div>

<p>
A Pipeline starts with a Data Source which is aware of geometric modeling
primitives such are curves, surfaces, meshes, etc. At the same time, a Data Source is not aware
of OCAF which allows us reusing the predefined set of Pipelines in situations when no persistent
storage is used or when the storage is variable (e.g., you may store a parametric curve in
different Node types and still use the same Pipeline class to draw it).
</p>

<div align="center"><img src="../imgs/situ_arch_03.png"/></div>

<p>
It is also possible to reuse Data Sources in different Pipelines. The latter is especially useful
when dealing with large objects. It is a Pipeline object which creates all used data sources,
algorithms (VTK "filters"), mappers and actors. By convention, a Pipeline may
have only one actor.
</p>

<div align="center"><img src="../imgs/situ_arch_04.png"/></div>

<p>
The persistent data is transferred from OCAF to a visualization Pipeline by means of the so called
Data Providers. A <i>Data Provider is used to handle variability</i> in the Data Model representations of a specific
object which needs to be rendered in a 3D scene. Thanks to the abstract Data Providers, all <i>Pipelines
can be kept OCAF-free</i>. The Pipelines only rely on the abstract interfaces of the corresponding Data Providers to
feed their Data Sources properly. All details related to the Data Model, specific Node and Parameter
types, and the relations between the data objects are encapsulated within implementations of Data
Providers. The correspondence between Pipelines and their Data Providers is managed by Presentation classes.
The Presentation classes construct Pipelines, Data Providers and associate them with each other.
</p>

<p>
All Parameters of all Nodes store their last modification time. This information is used to perform lazy visualization updates.
Each Pipeline stores its modification time as a member field. If the modification time of the sourced Parameters is
more recent than the modification time of a Pipeline, the Pipeline should be (re)executed to bring data to the up-to-date
state. Technically, since a Pipeline is not aware of OCAF and Data Model Parameters, the timestamp check is done by
a Data Provider.
</p>

<h1>Data Model facade</h1>

<p>
There is a single entry point to the Data Model which is <span class="code-inline">asiEngine_Model</span> class. Using this
class, you can iterate all Nodes in the project, find Nodes, delete and copy/paste them. This class is also responsible for
such basic operations as Open/Save, Undo/Redo and compatibility conversion between different versions of project files.
On start-up, the empty Data Model is created and populated with the predefined structure of Nodes.
</p>

</body>
</html>
