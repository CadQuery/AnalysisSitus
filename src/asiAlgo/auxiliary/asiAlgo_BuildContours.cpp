//-----------------------------------------------------------------------------
// Created on: 06 April 2016
//-----------------------------------------------------------------------------
// Copyright (c) 2017 Sergey Slyadnev
// Code covered by the MIT License
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

// Own include
#include <asiAlgo_BuildContours.h>

// OCCT includes
#include <BRep_Builder.hxx>
#include <BRepBuilderAPI_MakeEdge.hxx>
#include <BRepBuilderAPI_MakeFace.hxx>
#include <Geom_TrimmedCurve.hxx>
#include <Precision.hxx>
#include <ShapeExtend_WireData.hxx>
#include <ShapeFix_Face.hxx>
#include <ShapeFix_Wire.hxx>
#include <TopoDS_Edge.hxx>
#include <TopoDS_Wire.hxx>

// STL includes
#include <vector>

//! Constructor.
//! \param progress [in] Progress Notifier.
//! \param plotter  [in] Imperative Plotter.
asiAlgo_BuildContours::asiAlgo_BuildContours(ActAPI_ProgressEntry progress,
                                             ActAPI_PlotterEntry  plotter)
: ActAPI_IAlgorithm(progress, plotter)
{}

//! Performs reconstruction of contours from the given intersection data.
//! \param points      [in]  intersection points with history.
//! \param resultWires [out] reconstructed wires.
//! \param resultFaces [out] reconstructed faces.
//! \return true in case of success, false -- otherwise.
bool asiAlgo_BuildContours::operator()(const asiAlgo_IntersectionPointsCC& points,
                                       TopTools_IndexedMapOfShape&         resultWires,
                                       TopTools_IndexedMapOfShape&         resultFaces)
{
  // Get all involved surfaces
  NCollection_IndexedMap<Handle(Geom_Surface)> surfaces;
  for ( int p = 1; p <= points.Length(); ++p )
  {
    surfaces.Add(points(p)->pC1->S1);
    surfaces.Add(points(p)->pC1->S2);
    surfaces.Add(points(p)->pC2->S1);
    surfaces.Add(points(p)->pC2->S2);
  }

  // Loop over the involved surfaces
  for ( int s = 1; s <= surfaces.Extent(); ++s )
  {
    const Handle(Geom_Surface)& S = surfaces(s);

    // Find all curves generated by the current surface
    NCollection_IndexedMap<Handle(asiAlgo_IntersectionCurveSS)> genCurves;
    for ( int p = 1; p <= points.Length(); ++p )
    {
      if ( points(p)->pC1->S1 == S || points(p)->pC1->S2 == S )
        genCurves.Add(points(p)->pC1);
      //
      if ( points(p)->pC2->S1 == S || points(p)->pC2->S2 == S )
        genCurves.Add(points(p)->pC2);
    }

    // Find all points generated by the selected curves
    NCollection_IndexedMap<Handle(asiAlgo_IntersectionPointCC)> genPoints;
    for ( int p = 1; p <= points.Length(); ++p )
    {
      if ( genCurves.Contains(points(p)->pC1) && genCurves.Contains(points(p)->pC2) )
        genPoints.Add( points(p) );
    }

    Handle(ShapeExtend_WireData) WD = new ShapeExtend_WireData;

    // Trim generator curves
    for ( int c = 1; c <= genCurves.Extent(); ++c )
    {
      // Find extremities for the given curve
      const Handle(asiAlgo_IntersectionCurveSS)& section = genCurves(c);
      asiAlgo_IntersectionPointsCC               extremities;
      std::vector<double>                       parameters;
      //
      for ( int p = 1; p <= genPoints.Extent(); ++p )
      {
        if ( genPoints(p)->pC1 == section || genPoints(p)->pC2 == section )
        {
          extremities.Append( genPoints(p) );
          //
          if ( genPoints(p)->pC1 == section )
            parameters.push_back( genPoints(p)->W1 );
          else
            parameters.push_back( genPoints(p)->W2 );
        }
      }

      if ( parameters.size() != 2 )
      {
        std::cout << "Error: expected number of parameters is 2, while returned is "
                  << parameters.size() << std::endl;

        return false;
      }

      // Get parameters for the extremities
      std::cout << "Parameters on curve are [" << parameters[0] << ", " << parameters[1] << "]" << std::endl;
      //
      const double f = Min(parameters[0], parameters[1]);
      const double l = Max(parameters[0], parameters[1]);

      // Trim curve
      Handle(Geom_TrimmedCurve) tCurve = new Geom_TrimmedCurve(section->C, f, l);
      TopoDS_Edge edge = BRepBuilderAPI_MakeEdge(tCurve);
      //
      /////
      /*if ( s == 1 )
        edge.Reverse();*/

      WD->Add(edge);
    }

    // Add wire to the result
    TopoDS_Wire W = WD->Wire();
    resultWires.Add(W);

    ShapeFix_Wire WireHealer;
    WireHealer.Load(W);
    WireHealer.FixReorder();
    W = WireHealer.Wire();

    this->Plotter().ERASE_ALL();
    this->Plotter().DRAW_SHAPE(W, Color_Red, 0.5, false, "Wire");

    // Now build a face with a single outer wire
    TopoDS_Face F = BRepBuilderAPI_MakeFace( Handle(Geom_Surface)::DownCast( S->Copy() ),
                                             Precision::Confusion() );
    BRep_Builder BB;
    BB.Add(F, W);

    // TODO: this is a bad practice. Shape should be valid after face deletion
    ShapeFix_Face ShapeHealer(F);
    try
    {
      ShapeHealer.Perform();
    }
    catch ( ... )
    {
      std::cout << "Error: cannot heal face" << std::endl;
    }
    F = ShapeHealer.Face();

    // Add face to the result
    resultFaces.Add(F);
  }
  return true;
}
