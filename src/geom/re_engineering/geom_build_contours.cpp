//-----------------------------------------------------------------------------
// Created on: 06 April 2016
// Created by: Sergey SLYADNEV
//-----------------------------------------------------------------------------
// Web: http://dev.opencascade.org/
//-----------------------------------------------------------------------------

// Own include
#include <geom_build_contours.h>

// OCCT includes
#include <BRep_Builder.hxx>
#include <BRepBuilderAPI_MakeEdge.hxx>
#include <BRepBuilderAPI_MakeFace.hxx>
#include <Geom_TrimmedCurve.hxx>
#include <Precision.hxx>
#include <ShapeExtend_WireData.hxx>
#include <ShapeFix_Face.hxx>
#include <TopoDS_Edge.hxx>
#include <TopoDS_Wire.hxx>

// STL includes
#include <vector>

//! Constructor.
//! \param progress [in] Progress Notifier.
//! \param plotter  [in] Imperative Plotter.
geom_build_contours::geom_build_contours(ActAPI_ProgressEntry progress,
                                         ActAPI_PlotterEntry  plotter)
: ActAPI_IAlgorithm(progress, plotter)
{}

//! Performs reconstruction of contours from the given intersection data.
//! \param points      [in]  intersection points with history.
//! \param resultWires [out] reconstructed wires.
//! \param resultFaces [out] reconstructed faces.
//! \return true in case of success, false -- otherwise.
bool geom_build_contours::operator()(const geom_intersection_points_cc& points,
                                     TopTools_IndexedMapOfShape&        resultWires,
                                     TopTools_IndexedMapOfShape&        resultFaces)
{
  // Get all involved surfaces
  NCollection_IndexedMap<Handle(Geom_Surface)> surfaces;
  for ( int p = 1; p <= points.Length(); ++p )
  {
    surfaces.Add(points(p)->pC1->S1);
    surfaces.Add(points(p)->pC1->S2);
    surfaces.Add(points(p)->pC2->S1);
    surfaces.Add(points(p)->pC2->S2);
  }

  // Loop over the involved surfaces
  for ( int s = 1; s <= surfaces.Extent(); ++s )
  {
    const Handle(Geom_Surface)& S = surfaces(s);

    // Find all curves generated by the current surface
    NCollection_IndexedMap<Handle(geom_intersection_curve_ss)> genCurves;
    for ( int p = 1; p <= points.Length(); ++p )
    {
      if ( points(p)->pC1->S1 == S || points(p)->pC1->S2 == S )
        genCurves.Add(points(p)->pC1);
      //
      if ( points(p)->pC2->S1 == S || points(p)->pC2->S2 == S )
        genCurves.Add(points(p)->pC2);
    }

    // Find all points generated by the selected curves
    NCollection_IndexedMap<Handle(geom_intersection_point_cc)> genPoints;
    for ( int p = 1; p <= points.Length(); ++p )
    {
      if ( genCurves.Contains(points(p)->pC1) && genCurves.Contains(points(p)->pC2) )
        genPoints.Add( points(p) );
    }

    Handle(ShapeExtend_WireData) WD = new ShapeExtend_WireData;

    // Trim generator curves
    for ( int c = 1; c <= genCurves.Extent(); ++c )
    {
      // Find extremities for the given curve
      const Handle(geom_intersection_curve_ss)& section = genCurves(c);
      geom_intersection_points_cc               extremities;
      std::vector<double>                       parameters;
      //
      for ( int p = 1; p <= genPoints.Extent(); ++p )
      {
        if ( genPoints(p)->pC1 == section || genPoints(p)->pC2 == section )
        {
          extremities.Append( genPoints(p) );
          //
          if ( genPoints(p)->pC1 == section )
            parameters.push_back( genPoints(p)->W1 );
          else
            parameters.push_back( genPoints(p)->W2 );
        }
      }

      if ( parameters.size() != 2 )
      {
        std::cout << "Error: expected number of parameters is 2, while returned is "
                  << parameters.size() << std::endl;

        return false;
      }

      // Get parameters for the extremities
      std::cout << "Parameters on curve are [" << parameters[0] << ", " << parameters[1] << "]" << std::endl;
      //
      const double f = Min(parameters[0], parameters[1]);
      const double l = Max(parameters[0], parameters[1]);

      // Trim curve
      Handle(Geom_TrimmedCurve) tCurve = new Geom_TrimmedCurve(section->C, f, l);
      TopoDS_Edge edge = BRepBuilderAPI_MakeEdge(tCurve);
      //
      ///
      if ( s == 1 )
        edge.Reverse();

      WD->Add(edge);
    }

    // Add wire to the result
    TopoDS_Wire W = WD->Wire();
    resultWires.Add(W);

    // Now build a face with a single outer wire
    TopoDS_Face F = BRepBuilderAPI_MakeFace( Handle(Geom_Surface)::DownCast( S->Copy() ),
                                             Precision::Confusion() );
    BRep_Builder BB;
    BB.Add(F, W);

    // TODO: this is a bad practice. Shape should be valid after face deletion
    ShapeFix_Face ShapeHealer(F);
    try
    {
      ShapeHealer.Perform();
    }
    catch ( ... )
    {
      std::cout << "Error: cannot heal face" << std::endl;
    }
    F = ShapeHealer.Face();

    // Add face to the result
    resultFaces.Add(F);
  }
  return true;
}
